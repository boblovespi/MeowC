let foo: i32 -> i32 := x \mt x * x + x + 10 + 20;

let bar: i32 -> i32 := y \mt foo y + foo(y + 1);

let fac: i32 -> i32 := n \mt {
    1; if n = 0,
    n * fac(n - 1); otherwise.
};

let fib: i32 -> i32 := n \mt {
    0; if n = 0,
    1; if n = 1,
    fib(n - 1) + fib(n - 2); otherwise.
};

let procBased: i32 -> i32 := n \mt [m: i32;]
{
    m <- n;
    m <- m * n + 1;
    return n * m + 2;
};

let test: i32 -> i32 := n \mt {
    1; if n = 0,
    [m: i32;] {
        m <- n * n;
        return m + n + test(n - 1);
    }; otherwise.
};

let lotsAndLots: i32 -> i32 := n \mt {
    n; if n = 0,
    n - 10; if n = 1,
    n * n; if n = 2,
    n * n * n; if n = 3,
    n + 10; if n = 100,
    n + 100; if n = 1000,
    n + 1; otherwise.
};

let main: 1 := [
    num: i32;
]
{
    num <- 10;
    print "num: ";
    print num;
    num <- foo num;
    print "\nfoo num: ";
    print num;
    num <- bar num;
    print "\nbar foo num: ";
    print num;
    print "\n";
    print "fac 10: ";
    print fac 10;
    print "\nfib 10: ";
    print fib 10;
    print "\n";
};