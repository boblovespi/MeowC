let foo: i32 -> i32 := x |-> x * x + x + 10 + 20;

let bar: i32 -> i32 := y |-> foo y + foo(y + 1);

let fac: i32 -> i32 := n |-> {
    1; if n = 0,
    n * fac(n - 1); otherwise.
};

let fib: i32 -> i32 := n |-> {
    0; if n = 0,
    1; if n = 1,
    fib(n - 1) + fib(n - 2); otherwise.
};

let procBased: i32 -> i32 := n |-> [m: i32;]
{
    m <- n;
    m <- m * n + 1;
    return n * m + 2;
};

let test: i32 -> i32 := n |-> {
    1; if n = 0,
    [m: i32;] {
        m <- n * n;
        return m + n + test(n - 1);
    }; otherwise.
};

let lotsAndLots: i32 -> i32 := n |-> {
    n;          if n = 0,
    n - 10;     if n = 1,
    n * n;      if n = 2,
    n * n * n;  if n = 3,
    n + 10;     if n = 100,
    n + 100;    if n = 1000,
    n + 12;     if n < 0,
    n + 1;      otherwise.
};

let longFunc: i64 -> i64 := n |-> n * 2000000;

let main: 1 := [
    num: i32;
]
{
    num <- 10;
    print "num: ";
    print num;
    num <- foo num;
    print "\nfoo num: ";
    print num;
    num <- bar num;
    print "\nbar foo num: ";
    print num;
    print "\n";
    print "fac 10: ";
    print fac 10;
    print "\nfib 10: ";
    print fib 10;
    print "\n";
    longFunc 10;
};